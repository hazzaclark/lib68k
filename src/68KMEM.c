// COPYRIGHT (C) HARRY CLARK 2025
// MOTOROLA 68000 STANDALONE EMULATION LIBRARY

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF THE MEMORY ENCOMPASSING THIS EMULATOR
// THIS IS JUST AN EXTENSION OF LIB68K_MEM, THAT OF WHICH ISOLATED THE LOGIC PERTAINING
// TOWARDS THIS EMULATOR TO BE ABLE TO FOSTER AN ACCURATE MEMORY SCHEME

// NESTED INCLUDES

#include "68KMEM.h"

static M68K_MEM_BUFFER MEM_BUFFERS[M68K_MAX_BUFFERS];
static unsigned MEM_NUM_BUFFERS = 0;
U8 ENABLED_FLAGS = M68K_OPT_FLAGS;

const char* M68K_MEM_ERR[] = 
{
    "OK",
    "MEMORY OUT OF BOUNDS",
    "MEMORY IS READ ONLY",
    "MEMORY REGION IS UNMAPPED",
    "MEMORY HAS EXCEEDED BUS LIMIT",
    "MEMORY HAS TOO MANY BUFFERS",
    "MEMORY HAS AN INVALID SIZE FOR REGION",
    "MEMORY VIOLATES A RESERVED RANGE",
    "MEMORY OVERFLOW",
    "MEMORY ENCOUNTERED A BAD READ",
    "MEMORY ENCOUNTERED A BAD WRITE"
};

void ENABLE_TRACE_FLAG(U8 FLAG) { ENABLED_FLAGS |= FLAG; }
void DISABLE_TRACE_FLAG(U8 FLAG) { ENABLED_FLAGS &= ~FLAG; }
bool IS_TRACE_ENABLED(U8 FLAG) { return (ENABLED_FLAGS & FLAG) == FLAG; }

void SHOW_TRACE_STATUS(void)
{
    printf("\nTRACE CONFIG:\n"); \
    printf("  BASIC:            %s\n", IS_TRACE_ENABLED(M68K_OPT_BASIC) ? "ENABLED" : "DISABLED"); \
    printf("  VERBOSE:          %s\n", (VERBOSE_TRACE_HOOK == M68K_OPT_ON && IS_TRACE_ENABLED(M68K_OPT_VERB)) ? "ENABLED" : "DISABLED"); \
    printf("  DEVICE TRACE:     %s\n", IS_TRACE_ENABLED(M68K_OPT_DEVICE) ? "ENABLED" : "DISABLED"); \
    printf("  T0 FLAG:          %s  (SHIFT: 0x%02X)\n", M68K_FLAG_T0 ? "ON" : "OFF", M68K_T0_SHIFT); \
    printf("  T1 FLAG:          %s (SHIFT: 0x%02X)\n", M68K_FLAG_T1 ? "ON" : "OFF", M68K_T1_SHIFT); \
    printf("  T0 ACTIVE:        %s\n", IS_TRACE_ENABLED(M68K_T0_SHIFT) ? "YES" : "NO"); \
    printf("  T1 ACTIVE:        %s\n", IS_TRACE_ENABLED(M68K_T1_SHIFT) ? "YES" : "NO"); \
    printf("\n");
}

void SHOW_MEMORY_MAPS(void)
{
    printf("\n%s MEMORY MAPS:\n", M68K_CPU_STOPPED ? "AFTER" : "BEFORE");
    printf("----------------------------------------------------------------------------------------------\n");
    printf("START        END         SIZE    STATE      READS   WRITES   MOVES      ACCESS      VIOLATIONS  \n");
    printf("----------------------------------------------------------------------------------------------\n");

    for (unsigned INDEX = 0; INDEX < MEM_NUM_BUFFERS; INDEX++)
    {
        M68K_MEM_BUFFER* BUF = &MEM_BUFFERS[INDEX];
        printf("0x%08X 0x%08X    %3d%s    %2s     %6u  %6u   %6u          %s            %1u\n",
                BUF->BASE,
                BUF->BASE + BUF->SIZE - 1,
                FORMAT_SIZE(BUF->SIZE), 
                FORMAT_UNIT(BUF->SIZE),
                BUF->WRITE ? "RW" : "RO",
                BUF->USAGE.READ_COUNT,
                BUF->USAGE.WRITE_COUNT,
                BUF->USAGE.MOVE_COUNT,
                BUF->USAGE.ACCESSED ? "YES" : "NO",
                BUF->USAGE.VIOLATION);
    }

    printf("----------------------------------------------------------------------------------------------\n");
}

// FIND THE CURRENTLY EXECUTED MEMORY BUFFER IN CONJUNCTION WITH 
// THE MEMORY RANGES THAT ARE BEING USED

// THIS WAY, WE ARE ABLE TO CONCLUSIVELY VALIDATE THE MEMORY BEING PASSED
// THROUGH AS PER THE INNATE FUNCTIONALITY OF THE OPCODES

M68K_MEM_BUFFER* MEM_FIND(U32 ADDRESS)
{
    VERBOSE_TRACE("FOUND MEMORY: 0x%04X", ADDRESS);

    for(unsigned INDEX = 0; INDEX < MEM_NUM_BUFFERS; INDEX++)
    {
        // DEFINE THE BASE IN RELATION TO HOW MANY MAPS THERE ARE
        M68K_MEM_BUFFER* MEM_BASE = MEM_BUFFERS + INDEX;

        // CHECK FIRST TO SEE IF WE CAN ACTUALLY ACCESS THE MEMORY BUFFER
        // ORIGINALLY, ADDRESS CHECKING WAS PART OF THE MAIN NULL CHECKER (UNWANTED)

        if(MEM_BASE == NULL) { return NULL; }

        // CAN WE ACCESS THE MEMORY BEING PASSED THROUGH
        // IF SO, VALIDATE WHAT TYPE IT IS AND RETURN

        if((MEM_BASE->BUFFER != NULL) && 
                (ADDRESS >= MEM_BASE->BASE) && 
                ((ADDRESS - MEM_BASE->BASE) < MEM_BASE->SIZE))
        {
            VERBOSE_TRACE("ACCESSED: 0x%04X [%s] IN BUFFER %u: 0x%08X - 0x%08X\n", 
                ADDRESS, 
                MEM_BASE->WRITE ? "RW" : "RO", 
                INDEX, 
                MEM_BASE->BASE, 
                MEM_BASE->BASE + MEM_BASE->SIZE - 1);

            return MEM_BASE;
        }
    }

    VERBOSE_TRACE("NO BUFFER FOUND FOR ADDRESS: 0x%08X\n", ADDRESS);
    return NULL;
}

static U32 MEMORY_READ(U32 ADDRESS, U32 SIZE)
{
    VERBOSE_TRACE("READING ADDRESS: 0x%04X (SIZE = %d)", ADDRESS, SIZE);

    // BOUND CHECKS FOR INVALID ADDRESSING
    if(ADDRESS > M68K_MAX_ADDR_END || ADDRESS > M68K_MAX_MEMORY_SIZE)
    {
        MEM_ERROR(MEM_ERR_BOUNDS, SIZE, "ATTEMPT TO READ FROM AN ADDRESS RANGE BEYOND THE ADDRESSABLE SPACE: 0x%08X", ADDRESS);
        MEM_ERROR(MEM_ERR_RESERVED, SIZE, "ATTEMPT TO READ FROM RESERVED ADDRESS RANGE: 0x%08X", ADDRESS);
        goto MALFORMED_READ;
    }

    // FIND THE ADDRESS AND IT'S RELEVANT SIZE IN ACCORDANCE WITH WHICH VALUE IS BEING PROC.
    M68K_MEM_BUFFER* MEM_BASE = MEM_FIND(ADDRESS);

    if(MEM_BASE != NULL)
    {
        U32 OFFSET = (ADDRESS - MEM_BASE->BASE);
        U32 BYTES = SIZE / 8;

        if((OFFSET + BYTES + 1) > MEM_BASE->SIZE)
        {
            MEM_BASE->USAGE.VIOLATION++;
            MEM_ERROR(MEM_ERR_BOUNDS, SIZE, "READ OUT OF BOUNDS: OFFSET = %d, SIZE = %d, VIOLATION #%u", OFFSET, BYTES, MEM_BASE->USAGE.VIOLATION);
            goto MALFORMED_READ;
        }

        // FIRST WE READ AND DETERMINE THE READ STATISTICS OF THE CURRENT MEMORY MAP BEING ALLOCATED
        // THIS CHECK COMES AFTER WHICH WE DETERMINE THE SIZE OF THE MEMORY REGION AS THIS IS TO
        // AVOID POTENTIAL SPILL-OVERS WITH ADDITIONAL READS

        MEM_BASE->USAGE.READ_COUNT++;
        MEM_BASE->USAGE.LAST_READ = ADDRESS;
        MEM_BASE->USAGE.ACCESSED = true;

        
        // THIS MEMORY POINTER WILL ALLOCATE ITSELF RELATIVE TO THE BUFFER
        // AS WELL AS THE BIT SHIFT OFFSET THAT IS PRESENT WITH THE RESPECTIVE BIT VALUE

        U8* MEM_PTR = MEM_BASE->BUFFER + OFFSET;
        U32 MEM_RETURN = 0;

        switch (SIZE)
        {
            case MEM_SIZE_32:
                MEM_RETURN = *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR;
                break;
                
            case MEM_SIZE_16:
                MEM_RETURN = *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR;
                break;
                
            case MEM_SIZE_8:
                MEM_RETURN = *MEM_PTR;
                break;
        }

        MEM_TRACE("[READ]", ADDRESS, SIZE, MEM_RETURN);
        return MEM_RETURN;
    }

MALFORMED_READ:
    MEM_ERROR(MEM_ERR_UNMAPPED, SIZE, "NO BUFFER FOUND FOR ADDRESS: 0x%08X", ADDRESS);
    MEM_ERROR(MEM_ERR_BAD_READ, SIZE, "ADDRESS: 0x%08X", ADDRESS);
    return 0;
}

static void MEMORY_WRITE(U32 ADDRESS, U32 SIZE, U32 VALUE)
{
    M68K_MEM_BUFFER* MEM_BASE = MEM_FIND(ADDRESS);

    VERBOSE_TRACE("WRITING TO ADDRESS 0x%08X (SIZE = %d, VALUE = 0x%08X)\n", ADDRESS, SIZE, VALUE);

    // BOUND CHECKS FOR INVALID ADDRESSING
    if(ADDRESS > M68K_MAX_ADDR_END || ADDRESS > M68K_MAX_MEMORY_SIZE)
    {
        MEM_ERROR(MEM_ERR_BOUNDS, SIZE, "ATTEMPT TO WRITE TO AN ADDRESS RANGE BEYOND THE ADDRESSABLE SPACE: 0x%08X", ADDRESS);
        MEM_ERROR(MEM_ERR_RESERVED, SIZE, "ATTEMPT TO WRITE TO RESERVED ADDRESS RANGE: 0x%08X", ADDRESS);
        goto MALFORMED_WRITE;
    }

    if(MEM_BASE != NULL)
    {
        // BEFORE ANYTHING, WE NEED TO VALIDATE IF THE MEMORY MAP
        // IS EITHER RW OR JUST RO

        if(!MEM_BASE->WRITE) 
        {
            MEM_BASE->USAGE.VIOLATION++;
            MEM_ERROR(MEM_ERR_READONLY, SIZE, "WRITE ATTEMPT TO READ-ONLY MEMORY AT 0x%08X, VIOLATION #%u", ADDRESS, MEM_BASE->USAGE.VIOLATION);
            goto MALFORMED_WRITE;
        }

        U32 OFFSET = (ADDRESS - MEM_BASE->BASE);
        U32 BYTES = SIZE / 8;

        if((OFFSET + BYTES) > MEM_BASE->SIZE) 
        {
            MEM_BASE->USAGE.VIOLATION++;
            MEM_ERROR(MEM_ERR_BOUNDS, SIZE, "WRITE OUT OF BOUNDS: OFFSET = %d, SIZE = %d, VIOLATION #%u", OFFSET, BYTES, MEM_BASE->USAGE.VIOLATION);
            goto MALFORMED_WRITE;
        }

        // FIRST WE READ AND DETERMINE THE WRITE STATISTICS OF THE CURRENT MEMORY MAP BEING ALLOCATED
        // THIS CHECK COMES AFTER WHICH WE DETERMINE THE SIZE OF THE MEMORY REGION AS THIS IS TO
        // AVOID POTENTIAL SPILL-OVERS WITH ADDITIONAL WRITES

        MEM_BASE->USAGE.WRITE_COUNT++;
        MEM_BASE->USAGE.LAST_WRITE = ADDRESS;
        MEM_BASE->USAGE.ACCESSED = true;

        U8* MEM_PTR = MEM_BASE->BUFFER + OFFSET;
        MEM_TRACE("[WRITE]", ADDRESS, SIZE, VALUE);

        switch (SIZE)
        {
            case MEM_SIZE_32:
                *MEM_PTR++ = (VALUE >> 24) & M68K_LSB_MASK;
                *MEM_PTR++ = (VALUE >> 16) & M68K_LSB_MASK;
                *MEM_PTR++ = (VALUE >> 8) & M68K_LSB_MASK;
                *MEM_PTR = VALUE & M68K_LSB_MASK;
                break;

            case MEM_SIZE_16:
                *MEM_PTR++ = (VALUE >> 8) & M68K_LSB_MASK;
                *MEM_PTR = VALUE & M68K_LSB_MASK;
                break;
            
            case MEM_SIZE_8:
                *MEM_PTR = VALUE & M68K_LSB_MASK;
                break;
        }
        return;
    }

    MEM_ERROR(MEM_ERR_UNMAPPED, SIZE, "NO BUFFER FOUND FOR ADDRESS: 0x%08X", ADDRESS);

MALFORMED_WRITE:
    MEM_ERROR(MEM_ERR_BAD_WRITE, SIZE, "VALUE: 0x%0X, ADDRESS: 0x%08X", VALUE, ADDRESS);
}

// MEMORY MOVE OPERATIONS - HANDLES THE SPECIFICS BETWEEN SOURCE
// AND DESTINATION OPERATIONS
//
// LOOKS TO FIND THE SOURCE AND DESTINATION OPERANDS TO PROPERLY
// VALIDATE THEIR EXECUTION
static void MEMORY_MOVE(uint32_t SRC, uint32_t DEST, uint32_t SIZE, uint32_t COUNT)
{
    VERBOSE_TRACE("MOVING %u BYTES FROM 0x%08X TO 0x%08X\n", COUNT, SRC, DEST);

    // FIND BOTH OF THE CURRENT OPERANDS WITHIN THE OPERATION

    M68K_MEM_BUFFER* SRC_BUFFER = MEM_FIND(SRC);
    M68K_MEM_BUFFER* DEST_BUFFER = MEM_FIND(DEST);

    if(SRC_BUFFER == NULL)
    {
        MEM_ERROR(MEM_ERR_UNMAPPED, SIZE, "NO SOURCE BUFFER FOUND FOR ADDRESS: 0x%08X", SRC);
        return;
    }

    if(DEST_BUFFER == NULL)
    {
        MEM_ERROR(MEM_ERR_UNMAPPED, SIZE, "NO DESTINATION BUFFER FOUND FOR ADDRESS: 0x%08X", DEST);
        return;
    }

    // CAN WE WRITE TO SAID DESTINATION?!
    // ASSUME THAT WE HAVE THE PROPER CONDITIONS FOR THE HIGH BOUND OF THE EA
    // THAT OF WHICH ENCOMPASSESS THE WRITE CONDITION

    if(!DEST_BUFFER->WRITE)
    {
        DEST_BUFFER->USAGE.VIOLATION++;
        MEM_ERROR(MEM_ERR_READONLY, SIZE, "MOVE ATTEMPT TO READ-ONLY MEMORY: 0x%08X, VIOLATION: #%u", DEST, DEST_BUFFER->USAGE.VIOLATION);
    }

    // GET THE ALL ENCOMPASSING SIZE OF THE OPERATION
    U32 TRANSFER_SIZE = SIZE / 8;

    // DETERMINE THE CONCURRENT BYTES IS REQUIRED PER EACH OPERATION
    // SIZE IS ALL VARIABLE BASED ON THE DISTANCE BETWEEN INDIRECT AND EA
    for(U32 INDEX = 0; INDEX < COUNT; INDEX += TRANSFER_SIZE)
    {
        U32 CURRENT_SRC = SRC + INDEX;
        U32 CURRENT_DEST = DEST + INDEX;

        // READ FROM THE CURRENT SORUCE AGAINST THE SIZE
        // OF THE OPERATION
        U32 SRC_READ = MEMORY_READ(CURRENT_SRC, SIZE);

        // WRITE TO DESTINATION
        MEMORY_WRITE(CURRENT_DEST, SIZE, SRC_READ);
    }

    SRC_BUFFER->USAGE.MOVE_COUNT++;
    SRC_BUFFER->USAGE.LAST_MOVE_SRC = SRC;
    DEST_BUFFER->USAGE.MOVE_COUNT++;
    DEST_BUFFER->USAGE.LAST_MOVE_DEST = DEST;

    MEM_MOVE_TRACE(SRC, DEST, SIZE, COUNT);
} 

void MEMORY_MAP(U32 BASE, U32 END, bool WRITABLE) 
{
    U32 SIZE = (END - BASE) + 1;

    if(MEM_NUM_BUFFERS >= M68K_MAX_BUFFERS) 
    {
        MEM_ERROR(MEM_ERR_BUFFER, SIZE, "CANNOT MAP - TOO MANY BUFFERS (%d%s)", FORMAT_SIZE(SIZE), FORMAT_UNIT(SIZE));
        return;
    }

    if(END > M68K_MAX_ADDR_END)
    {
        MEM_ERROR( MEM_ERR_BUS, (U32)SIZE, "END ADDRESS 0x%08X EXCEEDS THE BUS LIMIT: (0x%08X - %d%s)", 
                  END, M68K_MAX_ADDR_END, FORMAT_SIZE(M68K_MAX_MEMORY_SIZE), FORMAT_UNIT(M68K_MAX_MEMORY_SIZE));
        return;
    }

    M68K_MEM_BUFFER* BUF = &MEM_BUFFERS[MEM_NUM_BUFFERS++];
    BUF->BASE = BASE;
    BUF->END = END;
    BUF->SIZE = SIZE;
    BUF->WRITE = WRITABLE;
    BUF->USAGE.MOVE_COUNT = 0;
    BUF->BUFFER = malloc(SIZE);
    memset(BUF->BUFFER, 0, SIZE);

    // DETERMINE WHICH MEMORY MAPS ARE BEING USED AT ANY GIVEN TIME
    // FOR NOW, WE ARE ONLY CONCERNED WITH THE RAM AND IO TO COMMUNICATE
    // WITH THE 68K'S BUS

    memset(&BUF->USAGE, 0, sizeof(M68K_MEM_USAGE));
    BUF->USAGE.ACCESSED = false;

    MEM_MAP_TRACE(MEM_MAP, BUF->BASE, BUF->END, BUF->SIZE, BUF->BUFFER);
}

unsigned int M68K_READ_MEMORY_8(unsigned int ADDRESS) { return MEMORY_READ(ADDRESS, MEM_SIZE_8); }
unsigned int M68K_READ_MEMORY_16(unsigned int ADDRESS) { return MEMORY_READ(ADDRESS, MEM_SIZE_16); }
unsigned int M68K_READ_MEMORY_32(unsigned int ADDRESS) { return MEMORY_READ(ADDRESS, MEM_SIZE_32); }
void M68K_WRITE_MEMORY_8(unsigned int ADDRESS, uint8_t VALUE) { MEMORY_WRITE(ADDRESS, MEM_SIZE_8, VALUE); }
void M68K_WRITE_MEMORY_16(unsigned int ADDRESS, uint16_t VALUE) { MEMORY_WRITE(ADDRESS, MEM_SIZE_16, VALUE); }
void M68K_WRITE_MEMORY_32(unsigned int ADDRESS, uint32_t VALUE) { MEMORY_WRITE(ADDRESS, MEM_SIZE_32, VALUE); }
void M68K_MOVE_MEMORY_8(unsigned SRC, unsigned DEST, unsigned COUNT)    { MEMORY_MOVE(SRC, DEST, MEM_SIZE_8, COUNT); }
void M68K_MOVE_MEMORY_16(unsigned SRC, unsigned DEST, unsigned COUNT)   { MEMORY_MOVE(SRC, DEST, MEM_SIZE_16, COUNT); }
void M68K_MOVE_MEMORY_32(unsigned SRC, unsigned DEST, unsigned COUNT)   { MEMORY_MOVE(SRC, DEST, MEM_SIZE_32, COUNT); }
