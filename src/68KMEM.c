// COPYRIGHT (C) HARRY CLARK 2025
// MOTOROLA 68000 STANDALONE EMULATION LIBRARY

// THIS FILE PERTAINS TOWARDS THE MODULARISATION OF THE MEMORY ENCOMPASSING THIS EMULATOR
// THIS IS JUST AN EXTENSION OF LIB68K_MEM, THAT OF WHICH ISOLATED THE LOGIC PERTAINING
// TOWARDS THIS EMULATOR TO BE ABLE TO FOSTER AN ACCURATE MEMORY SCHEME

// NESTED INCLUDES

#include "68KMEM.h"

static M68K_MEM_BUFFER MEM_BUFFERS[M68K_MAX_BUFFERS];
static unsigned MEM_NUM_BUFFERS = 0;
U8 ENABLED_FLAGS = M68K_OPT_FLAGS;
bool TRACE_ENABLED;

const char* M68K_MEM_ERR[] = 
{
    "OK",
    "MEMORY OUT OF BOUNDS",
    "MEMORY IS READ ONLY",
    "MEMORY REGION IS UNMAPPED",
    "MEMORY HAS EXCEEDED BUS LIMIT",
    "MEMORY HAS TOO MANY BUFFERS",
    "MEMORY HAS AN INVALID SIZE FOR REGION",
    "MEMORY VIOLATES A RESERVED RANGE",
    "MEMORY OVERFLOW",
    "MEMORY ENCOUNTERED A BAD READ",
    "MEMORY ENCOUNTERED A BAD WRITE"
};

void ENABLE_TRACE_FLAG(U8 FLAG) { ENABLED_FLAGS |= FLAG; }
void DISABLE_TRACE_FLAG(U8 FLAG) { ENABLED_FLAGS &= ~FLAG; }
bool IS_TRACE_ENABLED(U8 FLAG) { return (ENABLED_FLAGS & FLAG) == FLAG; }

void SHOW_TRACE_STATUS(void)
{
    printf("\nTRACE CONFIG:\n"); \
    printf("  BASIC:            %s\n", IS_TRACE_ENABLED(M68K_OPT_BASIC) ? "ENABLED" : "DISABLED"); \
    printf("  VERBOSE:          %s\n", (VERBOSE_TRACE_HOOK == M68K_OPT_ON && IS_TRACE_ENABLED(M68K_OPT_VERB)) ? "ENABLED" : "DISABLED"); \
    printf("  DEVICE TRACE:     %s\n", IS_TRACE_ENABLED(M68K_OPT_DEVICE) ? "ENABLED" : "DISABLED"); \
    printf("  T0 FLAG:          %s  (SHIFT: 0x%02X)\n", M68K_FLAG_T0 ? "ON" : "OFF", M68K_T0_SHIFT); \
    printf("  T1 FLAG:          %s (SHIFT: 0x%02X)\n", M68K_FLAG_T1 ? "ON" : "OFF", M68K_T1_SHIFT); \
    printf("  T0 ACTIVE:        %s\n", IS_TRACE_ENABLED(M68K_T0_SHIFT) ? "YES" : "NO"); \
    printf("  T1 ACTIVE:        %s\n", IS_TRACE_ENABLED(M68K_T1_SHIFT) ? "YES" : "NO"); \
    printf("\n");
}

void SHOW_MEMORY_MAPS(void)
{
    printf("\n%s MEMORY MAP(S):\n", M68K_CPU_STOPPED ? "AFTER EXEC" : "BEFORE EXEC");
    printf("---------------------------------------------------------------\n");
    printf("START        END         SIZE    STATE  READS   WRITES  ACCESS\n");
    printf("---------------------------------------------------------------\n");

    for (unsigned INDEX = 0; INDEX < MEM_NUM_BUFFERS; INDEX++)
    {
        M68K_MEM_BUFFER* BUF = &MEM_BUFFERS[INDEX];
        printf("0x%08X 0x%08X  %3d%s     %2s  %6u  %6u      %s\n",
                BUF->BASE,
                BUF->BASE + BUF->SIZE - 1,
                FORMAT_SIZE(BUF->SIZE), 
                FORMAT_UNIT(BUF->SIZE),
                BUF->WRITE ? "RW" : "RO",
                BUF->USAGE.READ_COUNT,
                BUF->USAGE.WRITE_COUNT,
                BUF->USAGE.ACCESSED ? "YES" : "NO");
    }

    printf("---------------------------------------------------------------\n");
}

// FIND THE CURRENTLY EXECUTED MEMORY BUFFER IN CONJUNCTION WITH 
// THE MEMORY RANGES THAT ARE BEING USED

// THIS WAY, WE ARE ABLE TO CONCLUSIVELY VALIDATE THE MEMORY BEING PASSED
// THROUGH AS PER THE INNATE FUNCTIONALITY OF THE OPCODES

static M68K_MEM_BUFFER* MEM_FIND(U32 ADDRESS)
{
    VERBOSE_TRACE("FOUND MEMORY: 0x%04X", ADDRESS);

    for(unsigned INDEX = 0; INDEX < MEM_NUM_BUFFERS; INDEX++)
    {
        // DEFINE THE BASE IN RELATION TO HOW MANY MAPS THERE ARE
        M68K_MEM_BUFFER* MEM_BASE = MEM_BUFFERS + INDEX;

        // CHECK FIRST TO SEE IF WE CAN ACTUALLY ACCESS THE MEMORY BUFFER
        // ORIGINALLY, ADDRESS CHECKING WAS PART OF THE MAIN NULL CHECKER (UNWANTED)

        if(MEM_BASE == NULL) { return NULL; }

        // CAN WE ACCESS THE MEMORY BEING PASSED THROUGH
        // IF SO, VALIDATE WHAT TYPE IT IS AND RETURN

        if((MEM_BASE->BUFFER != NULL) && 
                (ADDRESS >= MEM_BASE->BASE) && 
                ((ADDRESS - MEM_BASE->BASE) < MEM_BASE->SIZE))
        {
            VERBOSE_TRACE("ACCESSED: 0x%04X [%s] IN BUFFER %u: 0x%08X - 0x%08X\n", 
                ADDRESS, 
                MEM_BASE->WRITE ? "RW" : "RO", 
                INDEX, 
                MEM_BASE->BASE, 
                MEM_BASE->BASE + MEM_BASE->SIZE - 1);

            return MEM_BASE;
        }
    }

    VERBOSE_TRACE("NO BUFFER FOUND FOR ADDRESS: 0x%08X\n", ADDRESS);
    return NULL;
}

static U32 MEMORY_READ(U32 ADDRESS, U32 SIZE)
{
    VERBOSE_TRACE("READING ADDRESS: 0x%04X (SIZE = %d)", ADDRESS, SIZE);

    // BOUND CHECKS FOR INVALID ADDRESSING
    if(ADDRESS > M68K_MAX_ADDR_END || ADDRESS > M68K_MAX_MEMORY_SIZE)
    {
        MEM_ERROR(MEM_ERR, MEM_ERR_BOUNDS, SIZE, "ATTEMPT TO READ FROM AN ADDRESS RANGE BEYOND THE ADDRESSABLE SPACE: 0x%08X", ADDRESS);
        MEM_ERROR(MEM_ERR, MEM_ERR_RESERVED, SIZE, "ATTEMPT TO READ FROM RESERVED ADDRESS RANGE: 0x%08X", ADDRESS);
        goto MALFORMED_READ;
    }

    // FIND THE ADDRESS AND IT'S RELEVANT SIZE IN ACCORDANCE WITH WHICH VALUE IS BEING PROC.
    M68K_MEM_BUFFER* MEM_BASE = MEM_FIND(ADDRESS);

    if(MEM_BASE != NULL)
    {
        U32 OFFSET = (ADDRESS - MEM_BASE->BASE);
        U32 BYTES = SIZE / 8;

        if((OFFSET + BYTES + 1) > MEM_BASE->SIZE)
        {
            MEM_BASE->USAGE.VIOLATION++;
            MEM_ERROR(MEM_ERR, MEM_ERR_BOUNDS, SIZE, "READ OUT OF BOUNDS: OFFSET = %d, SIZE = %d, VIOLATION #%u", OFFSET, BYTES, MEM_BASE->USAGE.VIOLATION);
            goto MALFORMED_READ;
        }

        // FIRST WE READ AND DETERMINE THE READ STATISTICS OF THE CURRENT MEMORY MAP BEING ALLOCATED
        // THIS CHECK COMES AFTER WHICH WE DETERMINE THE SIZE OF THE MEMORY REGION AS THIS IS TO
        // AVOID POTENTIAL SPILL-OVERS WITH ADDITIONAL READS

        MEM_BASE->USAGE.READ_COUNT++;
        MEM_BASE->USAGE.LAST_READ = ADDRESS;
        MEM_BASE->USAGE.ACCESSED = true;

        
        // THIS MEMORY POINTER WILL ALLOCATE ITSELF RELATIVE TO THE BUFFER
        // AS WELL AS THE BIT SHIFT OFFSET THAT IS PRESENT WITH THE RESPECTIVE BIT VALUE

        U8* MEM_PTR = MEM_BASE->BUFFER + OFFSET;
        U32 MEM_RETURN = 0;

        switch (SIZE)
        {
            case MEM_SIZE_32:
                MEM_RETURN = *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR;
                break;
                
            case MEM_SIZE_16:
                MEM_RETURN = *MEM_PTR++;
                MEM_RETURN = (MEM_RETURN << 8) | *MEM_PTR;
                break;
                
            case MEM_SIZE_8:
                MEM_RETURN = *MEM_PTR;
                break;
        }

        MEM_TRACE(MEM_READ, ADDRESS, SIZE, MEM_RETURN);
        return MEM_RETURN;
    }

MALFORMED_READ:
    MEM_ERROR(MEM_ERR, MEM_ERR_UNMAPPED, SIZE, "NO BUFFER FOUND FOR ADDRESS: 0x%08X", ADDRESS);
    MEM_ERROR(MEM_ERR, MEM_ERR_BAD_READ, SIZE, "ADDRESS: 0x%08X", ADDRESS);
    return 0;
}

static void MEMORY_WRITE(U32 ADDRESS, U32 SIZE, U32 VALUE)
{
    M68K_MEM_BUFFER* MEM_BASE = MEM_FIND(ADDRESS);

    VERBOSE_TRACE("WRITING TO ADDRESS 0x%08X (SIZE = %d, VALUE = 0x%08X)\n", ADDRESS, SIZE, VALUE);

    // BOUND CHECKS FOR INVALID ADDRESSING
    if(ADDRESS > M68K_MAX_ADDR_END || ADDRESS > M68K_MAX_MEMORY_SIZE)
    {
        MEM_ERROR(MEM_ERR, MEM_ERR_BOUNDS, SIZE, "ATTEMPT TO WRITE TO AN ADDRESS RANGE BEYOND THE ADDRESSABLE SPACE: 0x%08X", ADDRESS);
        MEM_ERROR(MEM_ERR, MEM_ERR_RESERVED, SIZE, "ATTEMPT TO WRITE TO RESERVED ADDRESS RANGE: 0x%08X", ADDRESS);
        goto MALFORMED_WRITE;
    }

    if(MEM_BASE != NULL)
    {
        // BEFORE ANYTHING, WE NEED TO VALIDATE IF THE MEMORY MAP
        // IS EITHER RW OR JUST RO

        if(!MEM_BASE->WRITE) 
        {
            MEM_BASE->USAGE.VIOLATION++;
            MEM_ERROR(MEM_ERR, MEM_ERR_READONLY, SIZE, "WRITE ATTEMPT TO READ-ONLY MEMORY AT 0x%08X, VIOLATION #%u", ADDRESS, MEM_BASE->USAGE.VIOLATION);
            goto MALFORMED_WRITE;
        }

        U32 OFFSET = (ADDRESS - MEM_BASE->BASE);
        U32 BYTES = SIZE / 8;

        if((OFFSET + BYTES + 1) > MEM_BASE->SIZE) 
        {
            MEM_BASE->USAGE.VIOLATION++;
            MEM_ERROR(MEM_ERR, MEM_ERR_BOUNDS, SIZE, "WRITE OUT OF BOUNDS: OFFSET = %d, SIZE = %d, VIOLATION #%u", OFFSET, BYTES, MEM_BASE->USAGE.VIOLATION);
            goto MALFORMED_WRITE;
        }

        // FIRST WE READ AND DETERMINE THE WRITE STATISTICS OF THE CURRENT MEMORY MAP BEING ALLOCATED
        // THIS CHECK COMES AFTER WHICH WE DETERMINE THE SIZE OF THE MEMORY REGION AS THIS IS TO
        // AVOID POTENTIAL SPILL-OVERS WITH ADDITIONAL WRITES

        MEM_BASE->USAGE.WRITE_COUNT++;
        MEM_BASE->USAGE.LAST_WRITE = ADDRESS;
        MEM_BASE->USAGE.ACCESSED = true;

        U8* MEM_PTR = MEM_BASE->BUFFER + OFFSET;
        MEM_TRACE(MEM_WRITE, ADDRESS, SIZE, VALUE);

        switch (SIZE)
        {
            case MEM_SIZE_32:
                *MEM_PTR++ = (VALUE >> 24) & M68K_LSB_MASK;
                *MEM_PTR++ = (VALUE >> 16) & M68K_LSB_MASK;
                *MEM_PTR++ = (VALUE >> 8) & M68K_LSB_MASK;
                *MEM_PTR = VALUE & M68K_LSB_MASK;
                break;

            case MEM_SIZE_16:
                *MEM_PTR++ = (VALUE >> 8) & M68K_LSB_MASK;
                *MEM_PTR = VALUE & M68K_LSB_MASK;
                break;
            
            case MEM_SIZE_8:
                *MEM_PTR = VALUE & M68K_LSB_MASK;
                break;
        }
        return;
    }

    MEM_ERROR(MEM_ERR, MEM_ERR_UNMAPPED, SIZE, "NO BUFFER FOUND FOR ADDRESS: 0x%08X", ADDRESS);

MALFORMED_WRITE:
    MEM_ERROR(MEM_ERR, MEM_ERR_BAD_WRITE, SIZE, "VALUE: 0x%0X, ADDRESS: 0x%08X", VALUE, ADDRESS);
}

void MEMORY_MAP(U32 BASE, U32 END, bool WRITABLE) 
{
    U32 SIZE = (END - BASE) + 1;

    if(MEM_NUM_BUFFERS >= M68K_MAX_BUFFERS) 
    {
        MEM_ERROR(MEM_ERR, MEM_ERR_BUFFER, SIZE, "CANNOT MAP - TOO MANY BUFFERS (%d%s)", FORMAT_SIZE(SIZE), FORMAT_UNIT(SIZE));
        return;
    }

    if(END > M68K_MAX_ADDR_END)
    {
        MEM_ERROR(MEM_ERR, MEM_ERR_BUS, (U32)SIZE, "END ADDRESS 0x%08X EXCEEDS THE BUS LIMIT: (0x%08X - %d%s)", 
                  END, M68K_MAX_ADDR_END, FORMAT_SIZE(M68K_MAX_MEMORY_SIZE), FORMAT_UNIT(M68K_MAX_MEMORY_SIZE));
        return;
    }

    M68K_MEM_BUFFER* BUF = &MEM_BUFFERS[MEM_NUM_BUFFERS++];
    BUF->BASE = BASE;
    BUF->END = END;
    BUF->SIZE = SIZE;
    BUF->WRITE = WRITABLE;
    BUF->BUFFER = malloc(SIZE);
    memset(BUF->BUFFER, 0, SIZE);

    // DETERMINE WHICH MEMORY MAPS ARE BEING USED AT ANY GIVEN TIME
    // FOR NOW, WE ARE ONLY CONCERNED WITH THE RAM AND IO TO COMMUNICATE
    // WITH THE 68K'S BUS

    memset(&BUF->USAGE, 0, sizeof(M68K_MEM_USAGE));
    BUF->USAGE.ACCESSED = false;

    MEM_MAP_TRACE(MEM_MAP, BUF->BASE, BUF->END, BUF->SIZE, BUF->BUFFER);
}

unsigned int M68K_READ_MEMORY_8(unsigned int ADDRESS) { return MEMORY_READ(ADDRESS, MEM_SIZE_8); }
unsigned int M68K_READ_MEMORY_16(unsigned int ADDRESS) { return MEMORY_READ(ADDRESS, MEM_SIZE_16); }
unsigned int M68K_READ_MEMORY_32(unsigned int ADDRESS) { return MEMORY_READ(ADDRESS, MEM_SIZE_32); }
void M68K_WRITE_MEMORY_8(unsigned int ADDRESS, uint8_t VALUE) { MEMORY_WRITE(ADDRESS, MEM_SIZE_8, VALUE); }
void M68K_WRITE_MEMORY_16(unsigned int ADDRESS, uint16_t VALUE) { MEMORY_WRITE(ADDRESS, MEM_SIZE_16, VALUE); }
void M68K_WRITE_MEMORY_32(unsigned int ADDRESS, uint32_t VALUE) { MEMORY_WRITE(ADDRESS, MEM_SIZE_32, VALUE); }

